#include "input.h"
#include "../audio/audio.h"

#define ACCEL 1
// give access to the var needed to quit the game
extern bool running;

// give access to screen size data
extern int window_x, window_y;

// Center of the player's screen.
extern float view_x;
extern float view_y;

//
// QUICK HACK FOR AIMING
//
int rotating = 0;

// detect the BOGUS x11 keyup event generated on keydown
bool just_keyed_down = false;
bool just_clicked = false;

//TODO move this to the client datastructure
int mouse_x = 0;
int mouse_y = 0;
bool m1_held = false;
int mouse_angle = 0;
bool mouse_moved = false;

void client_input(ent* e) {
    float up = e->get_dir().get_y();
    float right = e->get_dir().get_x();
    SDL_Event event;
    
    //
    // check all of the keyboard and mouse events
    //
    while(SDL_PollEvent(&event)) {
        mouse_moved = false;
        just_keyed_down = false;
        just_clicked = false;
        if (event.type == SDL_QUIT) // window was closed (not a keyboard event)
            running = false;
        switch( event.type ) {
            //
            // key was pressed
            //
            case SDL_KEYDOWN:
                // ignore auto repeat
                if (event.key.repeat == 1)
                    continue;
                // used to detect bogus inputs
                just_keyed_down = true;
                //
                // find the key codes with this:
                //
                //printf("Key was pressed: %d\n", event.key.keysym.sym);
                switch(event.key.keysym.sym) {
                    // here are the keyboard inputs!
                    
                    // close the game
                    case SDLK_ESCAPE:
                        running = false;
                        break;
                    case SDLK_q:
                        running = false;
                        break;
                    
                    // movement with WASD
                    case SDLK_a:
                        right -= ACCEL;
                        break;
                    case SDLK_d:
                        right += ACCEL;
                        break;
                    case SDLK_w:
                        up -= ACCEL;
                        break;
                    case SDLK_s:
                        up += ACCEL;
                        break;
                        
                    // sprint
                    case 1073742049: // shift key
                        // toggle sprinting state
                        if (e->get_state(state_player_speed) != 4)
                            e->set_state(state_player_speed, 4);//running speed
                        else
                            e->set_state(state_player_speed, 2);//walking speed
                        break;
                        
                    // sneak
                    case 1073742048: // ctrl key
                        // toggle sneaking state
                        if (e->get_state(state_player_speed) != 0)
                            e->set_state(state_player_speed, 0);
                        else
                            e->set_state(state_player_speed, 2);//walking speed
                        break;
                        
                    // aim left
                    case 1073741904: // left arrow
                        rotating -= 1;
                        break;
                        
                    // aim right
                    case 1073741903: // right arrow
                        rotating += 1;
                        break;
                    
                    // aim reverse (180 degree turn)
                    case 1073741906: // up arrow
                        //TODO redo this
                        mouse_angle += 180;
                        printf("Rotating...\n");
                        Mix_PlayMusic(music, 0); //HACK
                        break;
                        
                    // end of key up processing
                    default:
                        break;
                }
            //
            // key was released
            //
            // a bogus keyup is generated by the x server on key down (very annoying)
            case SDL_KEYUP:
                // ignore auto repeat
                if (event.key.repeat == 1 || just_keyed_down)
                    continue;
                switch(event.key.keysym.sym) {                        
                    // WASD
                    case SDLK_a:
                        right += ACCEL;
                        break;
                    case SDLK_d:
                        right -= ACCEL;
                        break;
                    case SDLK_w:
                       up += ACCEL;
                        break;
                    case SDLK_s:
                        up -= ACCEL;
                        break;
                        
                    // aim left
                    case 1073741904: // left arrow
                        rotating += 1;
                        break;
                        
                    // aim right
                    case 1073741903: // right arrow
                        rotating -= 1;
                        break;
                        
                        
                    default:
                        break;
            }
        //
        // mouse events
        //
        case (SDL_MOUSEMOTION):
            if (event.type != 769) { // ignore bogus "keyup" move event
                mouse_moved = true;
            }
            break;
        case (SDL_MOUSEBUTTONDOWN):
            just_clicked = true;
            switch(event.button.button) {
                case 1: // left click
                    //printf("Left click down.\n");
                    m1_held = true;
                    SDL_GetMouseState(&mouse_x, &mouse_y);
                    //(int)view_x
                    /*
                    printf(
                        "(%d, %d)\n", 
                        (mouse_x-window_x/2),
                        (mouse_y-window_y/2)
                    );
                    */
                    Mix_PlayChannel(-1, sound, 0);
                    break;
                case 2: // middle click
                    //printf("Middle click down.\n");
                    break;
                case 3: // right click
                    //printf("Right click down.\n");
                    break;
                default:
                    break;
        }
        case (SDL_MOUSEBUTTONUP):
            // ignore the bogus click up event
            if (just_clicked)
                continue;
            switch(event.button.button) {
                case 1: // left click
                    //printf("Left click up.\n");
                    m1_held = false;
                    break;
                case 2: // middle click
                    //printf("Middle click up.\n");
                    break;
                case 3: // right click
                    //printf("Right click up.\n");
                    break;
                default:
                    break;
        }
        default:
            break;
        }
    } // end of input event queue loop
    
    // send movement direction to the entity
    e->set_dir(vec2f {right, up});
    
    // send the rotation to the gun
    if (rotating < 0)
        mouse_angle -= 1;
    if (rotating > 0)
        mouse_angle += 1;
    // TODO change rotation
    //TODO something with this
    // only override keyboard aim if mouse is moving
    SDL_GetMouseState(&mouse_x, &mouse_y);
    mouse_x = (mouse_x - window_x/2);
    mouse_y = (mouse_y - window_y/2);
    if (mouse_moved == true) {
        mouse_angle = atan2(mouse_y, mouse_x) * 180 / M_PI;
    }
    if (mouse_angle < 0)
            mouse_angle += 360;
}
